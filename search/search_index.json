{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Packages regex","title":"regex"},{"location":"regex--index/","text":"Regex package \u00b6 The Regex package provides support for Perl compatible regular expressions. Example program \u00b6 use \"regex\" actor Main new create(env: Env) => try let r = Regex(\"\\\\d+\")? if r == \"1234\" then env.out.print(\"1234 is a series of numbers\") end if r != \"Not a number\" then env.out.print(\"'Not a number' is not a series of numbers\") end let matched = r(\"There are 02 numbers in here.\")? env.out.print(matched(0)? + \" was matched\") env.out.print(\"The match started at \" + matched.start_pos().string()) env.out.print(\"The match ended at \" + matched.end_pos().string()) end try let r = Regex(\"(\\\\d+)?\\\\.(\\\\d+)?\")? let matched = r(\"123.456\")? env.out.print(matched(0)? + \" was matched\") env.out.print(\"The first match was \" + matched(1)?) env.out.print(\"The second match was \" + matched(2)?) end Public Types \u00b6 class Regex class MatchIterator class Match","title":"Package"},{"location":"regex--index/#regex-package","text":"The Regex package provides support for Perl compatible regular expressions.","title":"Regex package"},{"location":"regex--index/#example-program","text":"use \"regex\" actor Main new create(env: Env) => try let r = Regex(\"\\\\d+\")? if r == \"1234\" then env.out.print(\"1234 is a series of numbers\") end if r != \"Not a number\" then env.out.print(\"'Not a number' is not a series of numbers\") end let matched = r(\"There are 02 numbers in here.\")? env.out.print(matched(0)? + \" was matched\") env.out.print(\"The match started at \" + matched.start_pos().string()) env.out.print(\"The match ended at \" + matched.end_pos().string()) end try let r = Regex(\"(\\\\d+)?\\\\.(\\\\d+)?\")? let matched = r(\"123.456\")? env.out.print(matched(0)? + \" was matched\") env.out.print(\"The first match was \" + matched(1)?) env.out.print(\"The second match was \" + matched(2)?) end","title":"Example program"},{"location":"regex--index/#public-types","text":"class Regex class MatchIterator class Match","title":"Public Types"},{"location":"regex-Match/","text":"Match \u00b6 [Source] Contains match data for a combination of a regex and a subject. class ref Match Public Functions \u00b6 size \u00b6 [Source] Returns the capture size of the match. fun box size() : U32 val Returns \u00b6 U32 val start_pos \u00b6 [Source] Returns the character position of the first character in the match. fun box start_pos() : USize val Returns \u00b6 USize val end_pos \u00b6 [Source] Returns the character position of the last character in the match. fun box end_pos() : USize val Returns \u00b6 USize val apply[optional A: (( String iso | Array [ U8 val] iso) & Seq [ U8 val] iso)] \u00b6 [Source] Returns a capture by number. Raises an error if the index is out of bounds. fun box apply[optional A: ((String iso | Array[U8 val] iso) & Seq[U8 val] iso)]( i: U32 val) : A^ ? Parameters \u00b6 i: U32 val Returns \u00b6 A^ ? find[optional A: (( String iso | Array [ U8 val] iso) & Seq [ U8 val] iso)] \u00b6 [Source] Returns a capture by name. Raises an error if the named capture does not exist. fun box find[optional A: ((String iso | Array[U8 val] iso) & Seq[U8 val] iso)]( name: String box) : A^ ? Parameters \u00b6 name: String box Returns \u00b6 A^ ? groups \u00b6 [Source] Returns all of the captured subgroups. Groups that failed to capture anything will contain the empty string. fun box groups() : Array[String val] iso^ Returns \u00b6 Array [ String val] iso^ dispose \u00b6 [Source] Free the underlying PCRE2 data. fun ref dispose() : None val Returns \u00b6 None val","title":"class Match"},{"location":"regex-Match/#match","text":"[Source] Contains match data for a combination of a regex and a subject. class ref Match","title":"Match"},{"location":"regex-Match/#public-functions","text":"","title":"Public Functions"},{"location":"regex-Match/#size","text":"[Source] Returns the capture size of the match. fun box size() : U32 val","title":"size"},{"location":"regex-Match/#returns","text":"U32 val","title":"Returns"},{"location":"regex-Match/#start_pos","text":"[Source] Returns the character position of the first character in the match. fun box start_pos() : USize val","title":"start_pos"},{"location":"regex-Match/#returns_1","text":"USize val","title":"Returns"},{"location":"regex-Match/#end_pos","text":"[Source] Returns the character position of the last character in the match. fun box end_pos() : USize val","title":"end_pos"},{"location":"regex-Match/#returns_2","text":"USize val","title":"Returns"},{"location":"regex-Match/#applyoptional-a-string-iso-arrayu8-val-iso-sequ8-val-iso","text":"[Source] Returns a capture by number. Raises an error if the index is out of bounds. fun box apply[optional A: ((String iso | Array[U8 val] iso) & Seq[U8 val] iso)]( i: U32 val) : A^ ?","title":"apply[optional A: ((String iso | Array[U8 val] iso) &amp; Seq[U8 val] iso)]"},{"location":"regex-Match/#parameters","text":"i: U32 val","title":"Parameters"},{"location":"regex-Match/#returns_3","text":"A^ ?","title":"Returns"},{"location":"regex-Match/#findoptional-a-string-iso-arrayu8-val-iso-sequ8-val-iso","text":"[Source] Returns a capture by name. Raises an error if the named capture does not exist. fun box find[optional A: ((String iso | Array[U8 val] iso) & Seq[U8 val] iso)]( name: String box) : A^ ?","title":"find[optional A: ((String iso | Array[U8 val] iso) &amp; Seq[U8 val] iso)]"},{"location":"regex-Match/#parameters_1","text":"name: String box","title":"Parameters"},{"location":"regex-Match/#returns_4","text":"A^ ?","title":"Returns"},{"location":"regex-Match/#groups","text":"[Source] Returns all of the captured subgroups. Groups that failed to capture anything will contain the empty string. fun box groups() : Array[String val] iso^","title":"groups"},{"location":"regex-Match/#returns_5","text":"Array [ String val] iso^","title":"Returns"},{"location":"regex-Match/#dispose","text":"[Source] Free the underlying PCRE2 data. fun ref dispose() : None val","title":"dispose"},{"location":"regex-Match/#returns_6","text":"None val","title":"Returns"},{"location":"regex-MatchIterator/","text":"MatchIterator \u00b6 [Source] MatchIterator allows for calling code to repeatedly perform the same match against a subject string as an iterator. This lets callers repeat the match until no more matches exist. class ref MatchIterator is Iterator[Match ref] ref Implements \u00b6 Iterator [ Match ref] ref Constructors \u00b6 create \u00b6 [Source] Creates a new Match Iterator from a regular expression and a subject string. new ref create( regex': Regex box, subject': String val, offset': USize val = 0) : MatchIterator ref^ Parameters \u00b6 regex': Regex box subject': String val offset': USize val = 0 Returns \u00b6 MatchIterator ref^ Public Functions \u00b6 has_next \u00b6 [Source] Indicates whether there is another match available. fun box has_next() : Bool val Returns \u00b6 Bool val next \u00b6 [Source] Yields the next match to the regular expression or produces an error if there is no match. fun ref next() : Match ref ? Returns \u00b6 Match ref ?","title":"class MatchIterator"},{"location":"regex-MatchIterator/#matchiterator","text":"[Source] MatchIterator allows for calling code to repeatedly perform the same match against a subject string as an iterator. This lets callers repeat the match until no more matches exist. class ref MatchIterator is Iterator[Match ref] ref","title":"MatchIterator"},{"location":"regex-MatchIterator/#implements","text":"Iterator [ Match ref] ref","title":"Implements"},{"location":"regex-MatchIterator/#constructors","text":"","title":"Constructors"},{"location":"regex-MatchIterator/#create","text":"[Source] Creates a new Match Iterator from a regular expression and a subject string. new ref create( regex': Regex box, subject': String val, offset': USize val = 0) : MatchIterator ref^","title":"create"},{"location":"regex-MatchIterator/#parameters","text":"regex': Regex box subject': String val offset': USize val = 0","title":"Parameters"},{"location":"regex-MatchIterator/#returns","text":"MatchIterator ref^","title":"Returns"},{"location":"regex-MatchIterator/#public-functions","text":"","title":"Public Functions"},{"location":"regex-MatchIterator/#has_next","text":"[Source] Indicates whether there is another match available. fun box has_next() : Bool val","title":"has_next"},{"location":"regex-MatchIterator/#returns_1","text":"Bool val","title":"Returns"},{"location":"regex-MatchIterator/#next","text":"[Source] Yields the next match to the regular expression or produces an error if there is no match. fun ref next() : Match ref ?","title":"next"},{"location":"regex-MatchIterator/#returns_2","text":"Match ref ?","title":"Returns"},{"location":"regex-Regex/","text":"Regex \u00b6 [Source] A perl compatible regular expression. This uses the PCRE2 library, and attempts to enable JIT matching whenever possible. class ref Regex Constructors \u00b6 create \u00b6 [Source] Compile a regular expression. Raises an error for an invalid expression. new ref create( from: (String box | Array[U8 val] box), jit: Bool val = true) : Regex ref^ ? Parameters \u00b6 from: ( String box | Array [ U8 val] box) jit: Bool val = true Returns \u00b6 Regex ref^ ? Public Functions \u00b6 matches \u00b6 [Source] Creates a match iterator from the regular expression that will iterate over the supplied subject returning matches. fun box matches( subject: String val) : MatchIterator ref Parameters \u00b6 subject: String val Returns \u00b6 MatchIterator ref eq \u00b6 [Source] Return true on a successful match, false otherwise. fun box eq( subject: (String box | Array[U8 val] box)) : Bool val Parameters \u00b6 subject: ( String box | Array [ U8 val] box) Returns \u00b6 Bool val ne \u00b6 [Source] Return false on a successful match, true otherwise. fun box ne( subject: (String box | Array[U8 val] box)) : Bool val Parameters \u00b6 subject: ( String box | Array [ U8 val] box) Returns \u00b6 Bool val apply \u00b6 [Source] Match the supplied string, starting at the given offset. Returns a Match object that can give precise match details. Raises an error if there is no match. fun box apply( subject: (String val | Array[U8 val] val), offset: USize val = 0) : Match ref^ ? Parameters \u00b6 subject: ( String val | Array [ U8 val] val) offset: USize val = 0 Returns \u00b6 Match ref^ ? replace[optional A: ( Seq [ U8 val] iso & ( String iso | Array [ U8 val] iso))] \u00b6 [Source] Perform a match on the subject, starting at the given offset, and create a new string using the value as a replacement for what was matched. Raise an error if there is no match. fun box replace[optional A: (Seq[U8 val] iso & (String iso | Array[U8 val] iso))]( subject: (String val | Array[U8 val] val), value: (String box | Array[U8 val] box), offset: USize val = 0, global: Bool val = false) : A^ ? Parameters \u00b6 subject: ( String val | Array [ U8 val] val) value: ( String box | Array [ U8 val] box) offset: USize val = 0 global: Bool val = false Returns \u00b6 A^ ? split \u00b6 [Source] Split subject by non-empty occurrences of this pattern, returning a list of the substrings. fun box split( subject: String val, offset: USize val = 0) : Array[String val] iso^ ? Parameters \u00b6 subject: String val offset: USize val = 0 Returns \u00b6 Array [ String val] iso^ ? index \u00b6 [Source] Returns the index of a named capture. Raises an error if the named capture does not exist. fun box index( name: String box) : USize val ? Parameters \u00b6 name: String box Returns \u00b6 USize val ? dispose \u00b6 [Source] Free the underlying PCRE2 data. fun ref dispose() : None val Returns \u00b6 None val","title":"class Regex"},{"location":"regex-Regex/#regex","text":"[Source] A perl compatible regular expression. This uses the PCRE2 library, and attempts to enable JIT matching whenever possible. class ref Regex","title":"Regex"},{"location":"regex-Regex/#constructors","text":"","title":"Constructors"},{"location":"regex-Regex/#create","text":"[Source] Compile a regular expression. Raises an error for an invalid expression. new ref create( from: (String box | Array[U8 val] box), jit: Bool val = true) : Regex ref^ ?","title":"create"},{"location":"regex-Regex/#parameters","text":"from: ( String box | Array [ U8 val] box) jit: Bool val = true","title":"Parameters"},{"location":"regex-Regex/#returns","text":"Regex ref^ ?","title":"Returns"},{"location":"regex-Regex/#public-functions","text":"","title":"Public Functions"},{"location":"regex-Regex/#matches","text":"[Source] Creates a match iterator from the regular expression that will iterate over the supplied subject returning matches. fun box matches( subject: String val) : MatchIterator ref","title":"matches"},{"location":"regex-Regex/#parameters_1","text":"subject: String val","title":"Parameters"},{"location":"regex-Regex/#returns_1","text":"MatchIterator ref","title":"Returns"},{"location":"regex-Regex/#eq","text":"[Source] Return true on a successful match, false otherwise. fun box eq( subject: (String box | Array[U8 val] box)) : Bool val","title":"eq"},{"location":"regex-Regex/#parameters_2","text":"subject: ( String box | Array [ U8 val] box)","title":"Parameters"},{"location":"regex-Regex/#returns_2","text":"Bool val","title":"Returns"},{"location":"regex-Regex/#ne","text":"[Source] Return false on a successful match, true otherwise. fun box ne( subject: (String box | Array[U8 val] box)) : Bool val","title":"ne"},{"location":"regex-Regex/#parameters_3","text":"subject: ( String box | Array [ U8 val] box)","title":"Parameters"},{"location":"regex-Regex/#returns_3","text":"Bool val","title":"Returns"},{"location":"regex-Regex/#apply","text":"[Source] Match the supplied string, starting at the given offset. Returns a Match object that can give precise match details. Raises an error if there is no match. fun box apply( subject: (String val | Array[U8 val] val), offset: USize val = 0) : Match ref^ ?","title":"apply"},{"location":"regex-Regex/#parameters_4","text":"subject: ( String val | Array [ U8 val] val) offset: USize val = 0","title":"Parameters"},{"location":"regex-Regex/#returns_4","text":"Match ref^ ?","title":"Returns"},{"location":"regex-Regex/#replaceoptional-a-sequ8-val-iso-string-iso-arrayu8-val-iso","text":"[Source] Perform a match on the subject, starting at the given offset, and create a new string using the value as a replacement for what was matched. Raise an error if there is no match. fun box replace[optional A: (Seq[U8 val] iso & (String iso | Array[U8 val] iso))]( subject: (String val | Array[U8 val] val), value: (String box | Array[U8 val] box), offset: USize val = 0, global: Bool val = false) : A^ ?","title":"replace[optional A: (Seq[U8 val] iso &amp; (String iso | Array[U8 val] iso))]"},{"location":"regex-Regex/#parameters_5","text":"subject: ( String val | Array [ U8 val] val) value: ( String box | Array [ U8 val] box) offset: USize val = 0 global: Bool val = false","title":"Parameters"},{"location":"regex-Regex/#returns_5","text":"A^ ?","title":"Returns"},{"location":"regex-Regex/#split","text":"[Source] Split subject by non-empty occurrences of this pattern, returning a list of the substrings. fun box split( subject: String val, offset: USize val = 0) : Array[String val] iso^ ?","title":"split"},{"location":"regex-Regex/#parameters_6","text":"subject: String val offset: USize val = 0","title":"Parameters"},{"location":"regex-Regex/#returns_6","text":"Array [ String val] iso^ ?","title":"Returns"},{"location":"regex-Regex/#index","text":"[Source] Returns the index of a named capture. Raises an error if the named capture does not exist. fun box index( name: String box) : USize val ?","title":"index"},{"location":"regex-Regex/#parameters_7","text":"name: String box","title":"Parameters"},{"location":"regex-Regex/#returns_7","text":"USize val ?","title":"Returns"},{"location":"regex-Regex/#dispose","text":"[Source] Free the underlying PCRE2 data. fun ref dispose() : None val","title":"dispose"},{"location":"regex-Regex/#returns_8","text":"None val","title":"Returns"},{"location":"src/regex/match/","text":"primitive _Match class Match \"\"\" Contains match data for a combination of a regex and a subject. \"\"\" var _match: Pointer[_Match] let _subject: ByteSeq let _size: U32 new _create(subject: ByteSeq, m: Pointer[_Match]) => \"\"\" Store a match, a subject, and a size. \"\"\" _match = m _subject = subject _size = @pcre2_get_ovector_count_8[U32](m) fun size(): U32 => \"\"\" Returns the capture size of the match. \"\"\" _size fun start_pos(): USize => \"\"\" Returns the character position of the first character in the match. \"\"\" @pcre2_get_startchar_8[USize](_match) fun end_pos(): USize => \"\"\" Returns the character position of the last character in the match. \"\"\" var len = USize(0) @pcre2_substring_length_bynumber_8[I32](_match, U32(0), addressof len) start_pos() + (len - 1) fun apply[A: (ByteSeq iso & Seq[U8] iso) = String iso](i: U32): A^ ? => \"\"\" Returns a capture by number. Raises an error if the index is out of bounds. \"\"\" if i >= _size then error end var len = USize(0) var rc = @pcre2_substring_length_bynumber_8[I32](_match, i, addressof len) if rc != 0 then error end len = len + 1 let out = recover A(len) end len = out.space() rc = @pcre2_substring_copy_bynumber_8[I32](_match, i, out.cpointer(), addressof len) if rc != 0 then error end out.truncate(len) out fun find[A: (ByteSeq iso & Seq[U8] iso) = String iso] (name: String box): A^ ? => \"\"\" Returns a capture by name. Raises an error if the named capture does not exist. \"\"\" var len = USize(0) let rc = @pcre2_substring_length_byname_8[I32](_match, name.cstring(), addressof len) if rc != 0 then error end len = len + 1 let out = recover A(len) end len = out.space() @pcre2_substring_copy_byname_8[I32](_match, name.cstring(), out.cpointer(), addressof len) out.truncate(len) out fun groups(): Array[String] iso^ => \"\"\" Returns all of the captured subgroups. Groups that failed to capture anything will contain the empty string. \"\"\" let res = recover Array[String] end var i: U32 = 1 while i < _size do try let g: String = apply(i)? res.push(g) else res.push(\"\") end i = i + 1 end res fun ref dispose() => \"\"\" Free the underlying PCRE2 data. \"\"\" if not _match.is_null() then @pcre2_match_data_free_8[None](_match) _match = Pointer[_Match] end fun _final() => \"\"\" Free the underlying PCRE2 data. \"\"\" if not _match.is_null() then @pcre2_match_data_free_8[None](_match) end","title":"Match"},{"location":"src/regex/match_iterator/","text":"class MatchIterator is Iterator[Match] \"\"\" MatchIterator allows for calling code to repeatedly perform the same match against a subject string as an iterator. This lets callers repeat the match until no more matches exist. \"\"\" let _regex: Regex box let _subject: String var _offset: USize = 0 new create(regex': Regex box, subject': String, offset': USize = 0) => \"\"\" Creates a new Match Iterator from a regular expression and a subject string. \"\"\" _regex = regex' _subject = consume subject' _offset = offset' fun has_next() : Bool => \"\"\" Indicates whether there is another match available. \"\"\" try let m = _regex(_subject, _offset)? true else false end fun ref next(): Match ? => \"\"\" Yields the next match to the regular expression or produces an error if there is no match. \"\"\" let m = _regex(_subject, _offset)? _offset = m.end_pos() + 1 m","title":"Match iterator"},{"location":"src/regex/regex/","text":"\"\"\" # Regex package The Regex package provides support for Perl compatible regular expressions. ## Example program ```pony use \"regex\" actor Main new create(env: Env) => try let r = Regex(\"\\\\d+\")? if r == \"1234\" then env.out.print(\"1234 is a series of numbers\") end if r != \"Not a number\" then env.out.print(\"'Not a number' is not a series of numbers\") end let matched = r(\"There are 02 numbers in here.\")? env.out.print(matched(0)? + \" was matched\") env.out.print(\"The match started at \" + matched.start_pos().string()) env.out.print(\"The match ended at \" + matched.end_pos().string()) end try let r = Regex(\"(\\\\d+)?\\\\.(\\\\d+)?\")? let matched = r(\"123.456\")? env.out.print(matched(0)? + \" was matched\") env.out.print(\"The first match was \" + matched(1)?) env.out.print(\"The second match was \" + matched(2)?) end ``` \"\"\" use \"lib:pcre2-8\" primitive _Pattern primitive _PCRE2 fun utf(): U32 => 0x00080000 // PCRE2_UTF fun substitute_global(): U32 => 0x00000100 // PCRE2_SUBSTITUTE_GLOBAL fun not_empty(): U32 => 0x00000004 // PCRE2_NOTEMPTY fun err_no_memory(): I32 => -48 // PCRE2_ERROR_NOMEMORY class Regex \"\"\" A perl compatible regular expression. This uses the PCRE2 library, and attempts to enable JIT matching whenever possible. \"\"\" var _pattern: Pointer[_Pattern] let _jit: Bool new create(from: ByteSeq box, jit: Bool = true) ? => \"\"\" Compile a regular expression. Raises an error for an invalid expression. \"\"\" let opt: U32 = _PCRE2.utf() var err: I32 = 0 var erroffset: USize = 0 _pattern = @pcre2_compile_8[Pointer[_Pattern]](from.cpointer(), from.size(), _PCRE2.utf(), addressof err, addressof erroffset, Pointer[U8]) if _pattern.is_null() then error end _jit = jit and (@pcre2_jit_compile_8[I32](_pattern, U32(1)) == 0) fun matches(subject: String): MatchIterator => \"\"\" Creates a match iterator from the regular expression that will iterate over the supplied subject returning matches. \"\"\" MatchIterator(this, subject) fun eq(subject: ByteSeq box): Bool => \"\"\" Return true on a successful match, false otherwise. \"\"\" try let m = _match(subject, 0, 0)? @pcre2_match_data_free_8[None](m) true else false end fun ne(subject: ByteSeq box): Bool => \"\"\" Return false on a successful match, true otherwise. \"\"\" not eq(subject) fun apply(subject: ByteSeq, offset: USize = 0): Match^ ? => \"\"\" Match the supplied string, starting at the given offset. Returns a Match object that can give precise match details. Raises an error if there is no match. \"\"\" let m = _match(subject, offset, U32(0))? Match._create(subject, m) fun replace[A: (Seq[U8] iso & ByteSeq iso) = String iso]( subject: ByteSeq, value: ByteSeq box, offset: USize = 0, global: Bool = false) : A^ ? => \"\"\" Perform a match on the subject, starting at the given offset, and create a new string using the value as a replacement for what was matched. Raise an error if there is no match. \"\"\" if _pattern.is_null() then error end var opt = if global then _PCRE2.substitute_global() else U32(0) end var len = subject.size().max(64) let out = recover A(len) end len = out.space() var rc = I32(0) repeat rc = @pcre2_substitute_8[I32](_pattern, subject.cpointer(), subject.size(), offset, opt, Pointer[U8], Pointer[U8], value.cpointer(), value.size(), out.cpointer(), addressof len) if rc == _PCRE2.err_no_memory() then len = out.space() * 2 out.reserve(len) len = out.space() end until rc != _PCRE2.err_no_memory() end if rc <= 0 then error end out.truncate(len) out fun split(subject: String, offset: USize = 0): Array[String] iso^ ? => \"\"\" Split subject by non-empty occurrences of this pattern, returning a list of the substrings. \"\"\" if _pattern.is_null() then error end let out = recover Array[String] end var off = offset try while off < subject.size() do let m' = _match(subject, off, _PCRE2.not_empty())? let m = Match._create(subject, m') let off' = m.start_pos() out.push(subject.substring(off.isize(), off'.isize())) off = m.end_pos() + 1 end else out.push(subject.substring(off.isize())) end out fun index(name: String box): USize ? => \"\"\" Returns the index of a named capture. Raises an error if the named capture does not exist. \"\"\" let rc = @pcre2_substring_number_from_name[I32](_pattern, name.cstring()) if rc < 0 then error end rc.usize() fun ref dispose() => \"\"\" Free the underlying PCRE2 data. \"\"\" if not _pattern.is_null() then @pcre2_code_free_8[None](_pattern) _pattern = Pointer[_Pattern] end fun _match(subject: ByteSeq box, offset: USize, options: U32) : Pointer[_Match]? => \"\"\" Match the subject and keep the capture results. Raises an error if there is no match. \"\"\" if _pattern.is_null() then error end let m = @pcre2_match_data_create_from_pattern_8[Pointer[_Match]](_pattern, Pointer[U8]) let rc = if _jit then @pcre2_jit_match_8[I32](_pattern, subject.cpointer(), subject.size(), offset, options, m, Pointer[U8]) else @pcre2_match_8[I32](_pattern, subject.cpointer(), subject.size(), offset, options, m, Pointer[U8]) end if rc <= 0 then @pcre2_match_data_free_8[None](m) error end m fun _final() => \"\"\" Free the underlying PCRE2 data. \"\"\" if not _pattern.is_null() then @pcre2_code_free_8[None](_pattern) end","title":"Regex"}]}